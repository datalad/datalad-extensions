#!/usr/bin/env python3

import os
import os.path as op
import glob
import sys
import yaml

import jinja2

top_path = op.dirname(op.dirname(__file__))

# TODO: proper logigng etc

def log(msg, *args):
    print(msg % args)


class ExtensionSpec(dict):

    @property
    def name(self):
        return self["name"]

    # Some properties which might tune the value
    @property
    def github(self):
        from_spec = self.get("github", self.name.replace("_", "-"))
        gh_url = "datalad/{}".format(from_spec) \
            if '/' not in from_spec else from_spec
        return gh_url

    @property
    def githubdash(self):
        return self.github.replace("_", "-")

    @property
    def githubname(self):
        return self.github.split('/')[1]

    @property
    def pypi(self):
        return self.get("pypi", self.name.replace('_', '-'))

    @property
    def package(self):
        return self.get("package", self.name)

    @property
    def conda(self):
        return self.get('conda', self.package.replace('_', '-'))

    @property
    def apt_depends(self):
        return self.get("apt_depends", [])

    @property
    def extra_setup_steps(self):
        extras = self.get('extra_setup_steps', [])
        if extras:
            out = [f'{" " * 0 if idx == 0 else " " * 4}- {k}: {v}'
                   if k == 'name' else f'{" "*6}{k}: {v}'
                   for idx, extra in enumerate(extras) for k, v in extra.items()]
            return out

    @property
    def tester(self):
        return self.get('tester', 'pytest')

    @property
    def ci_badge(self):
        ci = self.get('ci', 'Travis').lower()
        if ci  == 'travis':
            return "https://travis-ci.com/{}.svg?branch=master" \
                   "".format(self.githubdash)
        elif ci == 'appveyor':
            return "https://ci.appveyor.com/api/projects/status/github/{}?" \
                   "branch=master&svg=true".format(self.github)
        else:
            raise RuntimeError("Unknown Ci specification: %s" % ci)

    @property
    def ci_link(self):
        ci = self.get('ci', 'Travis').lower()
        if ci == 'travis':
            return "https://travis-ci.com/github/{}".format(self.githubdash)
        elif ci == 'appveyor':
            user = self.get('ci-user')
            return "https://ci.appveyor.com/project/{user}/{githubname}/" \
                   "branch/master".format(user=user, githubname=self.githubname)

    #def __getattribute__(self, item):
    #    return self[item]


def jinja_render(tmpl, **kwargs):
    """Custom renderer, so we first replace github actions ${{ with a
    custom placeholder to avoid jinja tying to handle it
    """
    PLACEHOLDER = "[[["
    if PLACEHOLDER in tmpl:
        raise RuntimeError(
            "Detected placeholder %r already being present in the text"
            % PLACEHOLDER
        )
    tmpl_ = tmpl.replace("${{", PLACEHOLDER)
    out_ = jinja2.Template(tmpl_).render(**kwargs)
    return out_.replace(PLACEHOLDER, "${{")


def process_extension(ext_spec):
    render_kwargs = {
        "extension": ext_spec,
    }

    # TODO: proper recursive
    templates_dir = op.join(top_path, 'templates')
    for tmpl_p in glob.glob(op.join(templates_dir, '.github/*/*')):
        datalad_branches = ['master']
        if 'datalad_branch' in tmpl_p:
            datalad_branches += ['maint']
        for datalad_branch in datalad_branches:
            render_kwargs['datalad_branch'] = datalad_branch
            p = jinja_render(tmpl_p, **render_kwargs)
            if p == tmpl_p:
                log("Skipping %s since seems to be not extension specific", tmpl_p)
                continue

            with open(tmpl_p) as f:
                tmpl = f.read()
            rendered = jinja_render(tmpl, **render_kwargs)

            if rendered == tmpl:
                raise RuntimeError(
                    f"Rendered version of {tmpl_p} content is the same as template. "
                    "At the moment it is not expected"
                )

            prel_target = op.relpath(p, templates_dir)
            p_target = op.join(top_path, prel_target)
            if not op.exists(op.dirname(p_target)):
                os.makedirs(op.dirname(p_target))

            with open(p_target, "w") as f:
                f.write(rendered)

            log("Rendered %s", prel_target)


def generate_README(ext_specs):
    with open(op.join(top_path, "README.md"), "w") as f:
        f.write("""\
# DataLad healthchecks

This is a "dashboard" of various CIs of DataLad, its extensions, and underlying
3-rd party projects like git-annex.

**This README.md is autogenerated - do not edit.
  See [CONTRIBUTING.md](CONTRIBUTING.md) for more information.**

## Git-annex Status

 - Conda: ![Conda?](https://anaconda.org/conda-forge/git-annex/badges/version.svg)
    ![Updated](https://anaconda.org/conda-forge/git-annex/badges/latest_release_relative_date.svg)
    ![Platforms?](https://anaconda.org/conda-forge/git-annex/badges/platforms.svg)
 - Current snapshot build/tests + DataLad tests:
    [![Build git-annex snapshot](https://github.com/datalad/datalad-extensions/workflows/Build%20git-annex%20snapshot/badge.svg)](https://github.com/datalad/datalad-extensions/actions?query=workflow%3A%22Build+git-annex+snapshot%22)

## DataLad Status

 [![DataLad GitHub release](https://img.shields.io/github/release/datalad/datalad.svg)](https://GitHub.com/datalad/datalad/releases/)
 [![DataLad PyPI version fury.io](https://badge.fury.io/py/datalad.svg)](https://pypi.python.org/pypi/datalad/)
 ![Conda?](https://anaconda.org/conda-forge/datalad/badges/version.svg)
 - CI:
   [![Travis tests status](https://travis-ci.com/datalad/datalad.png?branch=master)](https://travis-ci.com/datalad/datalad)
   [![Build status](https://ci.appveyor.com/api/projects/status/github/datalad/datalad?branch=master&svg=true)](https://ci.appveyor.com/project/mih/datalad/branch/master)
   [![Documentation](https://readthedocs.org/projects/datalad/badge/?version=latest)](http://datalad.rtfd.org)
 - Misc:
   [![codecov.io](https://codecov.io/github/datalad/datalad/coverage.svg?branch=master)](https://codecov.io/github/datalad/datalad?branch=master)

## DataLad Extensions Status

""")
        columns = {
             'Name': 'ref',
             'Release': 'release_github',
             'PyPI Release': 'release_pypi',
             'Conda Release': 'release_conda',
             'CI: Released + DL master': 'ci_rel+dlmaster',
             'CI: Released + DL maint': 'ci_rel+dlmaint',
             'CI: master + DL Release': 'ci_master+dlrelease',
             'Codecov': 'codecov',
             'Issue Resolution': 'issues_restime',
             'Open Issues': 'issues_open'
        }

        def write_row(entries):
            f.write(' | '.join([''] + entries + ['']) + '\n')

        # Header
        write_row(list(columns))
        write_row(['---']*len(columns))
        # TODO: link to per-extension cron-github-CI results
        https_extension = "https://github.com/datalad/datalad-extensions"
        for ext, e in ext_specs.items():
            entry = {
                'ref': f"[{ext}](https://github.com/{e.github})",
                'release_github':      f'[![?](https://img.shields.io/github/release/{e.githubdash}.svg)](https://GitHub.com/{e.githubdash}/releases/)',
                'release_pypi':        f'[![PyPI version fury.io](https://badge.fury.io/py/{e.pypi}.svg)](https://pypi.python.org/pypi/{e.pypi}/)',
                'release_conda':       f'![-](https://anaconda.org/conda-forge/{e.conda}/badges/version.svg)',
                'ci_rel+dlmaster':     f'[![Released+DataLad master]({https_extension}/workflows/test-{ext}-master/badge.svg)]({https_extension}/actions?query=workflow%3Atest-{ext}-master)',
                'ci_rel+dlmaint':      f'[![Released+DataLad maint]({https_extension}/workflows/test-{ext}-maint/badge.svg)]({https_extension}/actions?query=workflow%3Atest-{ext}-maint)',
                'ci_master+dlrelease': f'[![master+Released Datalad]({e.ci_badge})]({e.ci_link})',
                'codecov':             f'[![codecov.io](https://codecov.io/github/{e.githubdash}/coverage.svg?branch=master)](https://codecov.io/github/{e.githubdash}?branch=master)',
                'issues_restime':      f'[![Average time to resolve an issue](http://isitmaintained.com/badge/resolution/{e.githubdash}.svg)](http://isitmaintained.com/project/{e.githubdash} "Average time to resolve an issue")',
                'issues_open':         f'[![Percentage of issues still open](http://isitmaintained.com/badge/open/{e.githubdash}.svg)](http://isitmaintained.com/project/{e.githubdash} "Percentage of issues still open")',
            }
            write_row([entry[k] for k in columns.values()])
                    # [![DOI](
                    # https://zenodo.org/badge/DOI/10.5281/zenodo.3368666.svg
                    # )](https://doi.org/10.5281/zenodo.3368666)
                    # f"[![Documentation](https://readthedocs.org/projects/{
                    # e.githubname}/badge/?version=latest)](http://{e.githubname}.rtfd.org)"
                    # f"[![License: MIT](
                    # https://img.shields.io/badge/License-MIT-yellow.svg)](
                    # https://opensource.org/licenses/MIT) 


def main(extensions):
    ext_specs = load_ext_specs()

    for ext in extensions or list(ext_specs):
        process_extension(ext_specs[ext])

    # We generate/update README.md for all extensions for now
    generate_README(ext_specs)


def load_ext_specs():
    with open(op.join(top_path, "extensions.yaml")) as f:
        spec = yaml.load(f.read(), Loader=yaml.BaseLoader)
    # ATM expecting only a single structure
    assert list(spec.keys()) == ['extensions']
    ext_specs = spec["extensions"]
    for ext in list(ext_specs):
        if not ext_specs[ext]: # Was None
            # If it had nothing -- prepare it to be a dict
            ext_specs[ext] = {}
        ext_spec = ext_specs[ext] \
            = ExtensionSpec(**ext_specs[ext])
        ext_spec["name"] = ext
    return ext_specs


if __name__ == "__main__":
    main(sys.argv[1:])
